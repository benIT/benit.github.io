<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[benIT]]></title>
    <link href="/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2019-01-25T14:14:11+00:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[How to make a christmas garland with a nginx reverse proxy and 3 apache backends under docker?]]></title>
            <link href="/blog/2019/01/25/docker-make-a-christmas-garland-with-nginx-apache"/>
            <updated>2019-01-25T00:00:00+00:00</updated>
            <id>/blog/2019/01/25/docker-make-a-christmas-garland-with-nginx-apache</id>
            <content type="html"><![CDATA[<h1 id="purpose">Purpose</h1>

<p>This posts deals with doing yourself a christmas garland!</p>

<p>We will be using :</p>

<ul>
<li>nginx as a reverse proxy</li>
<li>apache as a backend</li>
<li>docker as a plateforme  </li>
</ul>

<h1 id="repository">Repository</h1>

<p><a href="https://github.com/benIT/docker-nginx-reverse-proxy">You will find a demonstration repository here.</a></p>

<h1 id="demo">Demo</h1>

<p><a href="/video/docker-christmas-garland-demo.mp4">A video is available here.</a></p>

<p>If it does not work, download it from github repo:</p>

<pre><code>wget https://raw.githubusercontent.com/benIT/docker-nginx-reverse-proxy/master/demo.mp4
vlc demo.mp4
</code></pre>

<h1 id="conclusion">Conclusion</h1>

<p>Never forget that computing should always be fun!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Docker 101: docker-compose]]></title>
            <link href="/blog/2019/01/15/docker-docker-compose"/>
            <updated>2019-01-15T00:00:00+00:00</updated>
            <id>/blog/2019/01/15/docker-docker-compose</id>
            <content type="html"><![CDATA[<h1 id="docker-compose">Docker compose</h1>

<p>Purpose: compose is a tool designed to create multi-containers app.</p>

<h2 id="install">Install</h2>

<pre><code>sudo apt install python-pip
pip install docker-compose
</code></pre>

<h2 id="docker-compose.yml">docker-compose.yml</h2>

<p>The magic happens in a file named <code>docker-compose.yml</code></p>

<h2 id="run">Run</h2>

<pre><code>docker-compose up -d
</code></pre>

<h2 id="stop">Stop</h2>

<pre><code>docker-compose down -v
</code></pre>

<h2 id="networking">Networking</h2>

<p><code>docker-compose</code> handles the creation a private network:</p>

<pre><code>Creating network "n-tiers_default" with the default driver
Creating object-cache ... done
Creating pgsql        ... done
Creating web          ... done
</code></pre>

<h1 id="example">Example</h1>

<p>Better than words, take a look at this <a href="https://github.com/benIT/docker-compose-n-tiers">repo that illustrates a classical n-tiers web app</a></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Docker 101: networking]]></title>
            <link href="/blog/2019/01/14/docker-networking"/>
            <updated>2019-01-14T00:00:00+00:00</updated>
            <id>/blog/2019/01/14/docker-networking</id>
            <content type="html"><![CDATA[<h1 id="docker-running-containers-inside-a-bridge-network">Docker running containers inside a bridge network</h1>

<p>The purpose of this post is to isolate each tiers of our app into different containers.</p>

<p>We will create a private network and run containers inside this private network.</p>

<p><a href="https://docker-curriculum.com/#webapps-with-docker">This article is largely inspired by this great resource.</a></p>

<h2 id="networking">Networking</h2>

<h3 id="create-an-isolated-private-bridge-network">Create an isolated private bridge network</h3>

<pre><code>docker network create web-net    
</code></pre>

<h3 id="inspect-the-private-network">Inspect the private network</h3>

<pre><code>docker network inspect web-net
</code></pre>

<h3 id="run-a-container-inside-the-private-bridge-network-with-%60--net%60-option">Run a container inside the private bridge network with <code>--net</code> option</h3>

<pre><code>docker run --name pgsql-web --rm  -d --net web-net postgres:latest
docker run --name debian-web --rm -p 80:80 --net web-net -d benit/debian-web:latest
</code></pre>

<h3 id="inspect-the-private-network-to-get-ips-of-containers-of-the-private-network">Inspect the private network to get IPs of containers of the private network</h3>

<pre><code>docker network inspect web-net
</code></pre>

<p>gives:</p>

<pre><code> "Containers": {
            "3729ccbb14e514fd6c8b571ed9c985c28293cb5bfdb10c6c233773f50d6ba763": {
                "Name": "debian-web",
                "EndpointID": "c370cab93cdd2ac9f30f568a1709b8c998d2ca36106d5423b484a20aadbff84f",
                "MacAddress": "02:42:ac:12:00:03",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "61bcf5cd9838c8c2e66beef73a04a2704a3be7e2085a5c6b4ad58bd78f12a138": {
                "Name": "pgsql-web",
                "EndpointID": "128f50ead4974a725c04551cb284fec2c733a48375a4819096b0b623ff2af4ac",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
</code></pre>

<h2 id="putting-it-all-together">Putting it all together</h2>

<h3 id="let%27s-create-a-database">Let's create a database</h3>

<pre><code>docker container exec pgsql-web psql -U postgres -c "create database webapp";
docker container exec pgsql-web psql -U postgres -d webapp -c "CREATE TABLE account(user_id serial PRIMARY KEY,username VARCHAR (50) UNIQUE NOT NULL,created_on TIMESTAMP NOT NULL);" ;
docker container exec pgsql-web psql -U postgres -d webapp -c "INSERT INTO account (username,created_on ) VALUES ('foo','2019-01-01') ;" ;
docker container exec pgsql-web psql -U postgres -d webapp -c "INSERT INTO account (username,created_on ) VALUES ('bar','2019-01-02') ;" ;
</code></pre>

<h3 id="connect-database-container-from-webserver-container">Connect database container from webserver container</h3>

<pre><code>docker container exec -it debian-web  psql -U postgres -h 172.18.0.2 -d webapp -c "select * from account;" ;
</code></pre>

<p>gives:</p>

<pre><code> user_id | username |     created_on      
---------+----------+---------------------
       1 | foo      | 2019-01-01 00:00:00
       2 | bar      | 2019-01-02 00:00:00
(2 rows)
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Docker 101: Dockerfile]]></title>
            <link href="/blog/2019/01/14/docker-dockerfile"/>
            <updated>2019-01-14T00:00:00+00:00</updated>
            <id>/blog/2019/01/14/docker-dockerfile</id>
            <content type="html"><![CDATA[<h1 id="dockerfile">Dockerfile</h1>

<p>A <code>Dockerfile</code> is a text document that contains all the commands a user could call on the command line to assemble an image.</p>

<h2 id="example">Example</h2>

<p>You will find <a href="https://github.com/benIT/debian-web">in this repo</a> a running <code>Dockerfile</code>  based on a debian image that runs an Apache webserver.</p>

<p>You will find <a href="https://github.com/benIT/debian-web/blob/master/README.md">in this file</a> all the base commands to manage a <code>Dockerfile</code> .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Wordpress migration procedure]]></title>
            <link href="/blog/2018/04/27/wordpress-migration-procedure"/>
            <updated>2018-04-27T00:00:00+00:00</updated>
            <id>/blog/2018/04/27/wordpress-migration-procedure</id>
            <content type="html"><![CDATA[<h2 id="extract-source-site-filesystem">Extract source site filesystem</h2>

<pre><code>tar -czf mySite.tgz /var/www/mySite
</code></pre>

<h2 id="extract-source-site-database">Extract source site database</h2>

<pre><code>mysqldump -u mySite -p mySite &gt; mySite.sql
</code></pre>

<h2 id="transfert-source-fs-and-db-to-target-site">Transfert source fs and db to target site</h2>

<ul>
<li><p>Extract tar archive</p>

<pre><code>tar -czf mySite.tgz
</code></pre></li>
<li><p>Import database</p></li>
</ul>

<h2 id="migrate-database">Migrate database</h2>

<p>Wordpress stores url in database, some of them can be serialized so wa can't just replace them with a bash script.</p>

<p>The best and easier way is to use this project <a href="https://github.com/interconnectit/Search-Replace-DB">interconnectit/Search-Replace-DB</a> :</p>

<ul>
<li>download it</li>
<li>upload it to the wordpress root</li>
<li>open a browser at the matching url</li>
<li>fill the form to migrate your database</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Install keepass and kee on linux]]></title>
            <link href="/blog/2018/02/23/keepass-kee-linux"/>
            <updated>2018-02-23T00:00:00+00:00</updated>
            <id>/blog/2018/02/23/keepass-kee-linux</id>
            <content type="html"><![CDATA[<h2 id="install-keepass2">install keepass2</h2>

<pre><code>sudo add-apt-repository ppa:jtaylor/keepass
sudo apt-get update &amp;&amp; sudo apt-get install keepass2
</code></pre>

<h2 id="install-firefox-addon-%27kee%27">install firefox addon 'kee'</h2>

<ul>
<li><a href="https://addons.mozilla.org/fr/firefox/addon/keefox/?src=search">download it here</a></li>
<li><a href="https://github.com/kee-org/KeeFox/wiki/en-|-Getting-started#linux">kee doc here</a> with linux keepass requirement.</li>
</ul>

<h2 id="download-keepassrpc.plgx-plugin">download KeePassRPC.plgx plugin</h2>

<p><a href="https://github.com/kee-org/keepassrpc/releases">download KeePassRPC.plgx plugin</a></p>

<pre><code>sudo mkdir /usr/lib/keepass2/plugins
sudo cp 'KeePassRPC.plgx' '/usr/lib/keepass2/plugins/'
sudo apt-get install mono-complete
</code></pre>

<h2 id="restart-keepass-and-firefox">Restart keepass and firefox</h2>

<p>you should be prompt about kee to authorize keepass</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[mySQL to postgreSQL schema conversion]]></title>
            <link href="/blog/2018/01/22/mysql-2-pgsql-conversion"/>
            <updated>2018-01-22T00:00:00+00:00</updated>
            <id>/blog/2018/01/22/mysql-2-pgsql-conversion</id>
            <content type="html"><![CDATA[<h2 id="purpose">Purpose</h2>

<p>I was looking for a tool that convert a mysql db to a pgsql one.
<a href="https://github.com/philipsoutham/py-mysql2pgsql">philipsoutham/py-mysql2pgsql</a> does the trick and saved my day!</p>

<h2 id="install">Install</h2>

<pre><code>sudo apt-get install python-pip
pip install py-mysql2pgsql
</code></pre>

<h2 id="configure">Configure</h2>

<p>Edit configuration in <code>mysql2pgsql.yml</code></p>

<pre><code># if a socket is specified we will use that
# if tcp is chosen you can use compression
mysql:
 hostname: localhost
 port: 3306
 socket: /var/run/mysqld/mysqld.sock
 #socket: /tmp/mysql.sock
 username: emedia
 password: emedia
 database: emedia
 compress: false
destination:
 # if file is given, output goes to file, else postgres
 file: /vagrant/shared/migrationMysql2Pgsql.sql
 postgres:
  hostname: localhost
  port: 5432
  username: mysql2psql
  password:
  database: mysql2psql_test

# if tables is given, only the listed tables will be converted.  leave empty to convert all tables.
only_tables:
- lti2_consumer
- lti2_context
- lti2_nonce
- lti2_resource_link
- lti2_share_key
- lti2_tool_proxy
- lti2_user_result
# if exclude_tables is given, exclude the listed tables from the conversion.
#exclude_tables:
#- table3
#- table4

# if supress_data is true, only the schema definition will be exported/migrated, and not the data
supress_data: true

# if supress_ddl is true, only the data will be exported/imported, and not the schema
supress_ddl: false

# if force_truncate is true, forces a table truncate before table loading
force_truncate: false
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Setting up a memcached server with PHP7.X and a NGINX webserver]]></title>
            <link href="/blog/2018/01/11/php7-nginx-memcached-session"/>
            <updated>2018-01-11T00:00:00+00:00</updated>
            <id>/blog/2018/01/11/php7-nginx-memcached-session</id>
            <content type="html"><![CDATA[<h2 id="memcached-server-side">Memcached server side</h2>

<p>This server has private @IP : 192.168.33.14</p>

<h3 id="install-memcached%3A">Install memcached:</h3>

<pre><code>sudo apt-get install memcached
</code></pre>

<p>In <code>/etc/memcached.conf</code>, set up memory to 256 Mo:</p>

<pre><code>-m 256
</code></pre>

<p>In <code>/etc/memcached.conf</code>, set up listening private @IP of the server:</p>

<pre><code># Specify which IP address to listen on. The default is to listen on all IP addresses
# This parameter is one of the only security measures that memcached has, so make sure
# it's listening on a firewalled interface.
#-l 127.0.0.2
-l 192.168.33.14
</code></pre>

<h2 id="web-server-side">Web server side</h2>

<p>This server has private @IP : 192.168.33.11</p>

<h3 id="install-php-extension">Install PHP extension</h3>

<p>On the server that hosts nginx + php7.0:</p>

<pre><code>sudo apt-get install -y php-memcached
</code></pre>

<h3 id="configure-php">Configure PHP</h3>

<p>In <code>/etc/php/7.0/fpm/php.ini</code>:</p>

<pre><code>[Session]
; Handler used to store/retrieve data.
; http://php.net/session.save-handler
#session.save_handler = files
session.save_handler = memcached
session.save_path = 'tcp://192.162.33.14:11211'
</code></pre>

<h3 id="restart-services">Restart services</h3>

<pre><code>sudo service php7.0-fpm restart &amp;&amp; sudo service nginx restart
</code></pre>

<h3 id="check-config">Check config</h3>

<p>Create a phpinfo.php that calls <code>phpinfo()</code> and check memcached configuration.</p>

<h3 id="checking">Checking</h3>

<h3 id="checking-sessions-are-well-handled-by-memcached">Checking sessions are well handled by memcached</h3>

<p>Let's write a simple script to check sessions:</p>

<pre><code>session_start();
if(!isset($_SESSION['visit']))
{   
    echo "This is the first time you're visiting this server\n";
    $_SESSION['visit'] = 0;
}   
else
        echo "Your number of visits: ".$_SESSION['visit'] . "\n";

$_SESSION['visit']++;

echo "Server IP: ".$_SERVER['SERVER_ADDR'] . "\n";
echo "Client IP: ".$_SERVER['REMOTE_ADDR'] . "\n";
print_r($_COOKIE);
</code></pre>

<h3 id="checking-memcached-key%2Fvalue-server">Checking memcached key/value server</h3>

<p>Let's write a simple script to key/value access:</p>

<pre><code>$mem = new Memcached();
$mem-&gt;addServer("192.168.33.14", 11211);
$result = $mem-&gt;get("blah");
if ($result) {
    echo $result;
} else {
    echo "No matching key found yet. Let's start adding that now!";
    $mem-&gt;set("blah", "I am data!  I am held in memcached!") or die("Couldn't save anything to memcached...");
}   
</code></pre>

<h3 id="dumping-all-key%2Fvalue-records">Dumping all key/value records</h3>

<script src="https://gist.github.com/benIT/2e63d3541f4f46d9a47777d467549d2e.js"></script>

<h2 id="sources">Sources</h2>

<ul>
<li>https://www.digitalocean.com/community/tutorials/how-to-share-php-sessions-on-multiple-memcached-servers-on-ubuntu-14-04</li>
<li>http://www.servermom.org/install-use-memcached-nginx-php-7-ubuntu-16-04/3670/</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Configure moodle 3.x session handling with memcached]]></title>
            <link href="/blog/2018/01/11/configure-moodle-session-handling-with-memcached"/>
            <updated>2018-01-11T00:00:00+00:00</updated>
            <id>/blog/2018/01/11/configure-moodle-session-handling-with-memcached</id>
            <content type="html"><![CDATA[<p>This procedure has been tested on Moodle <a href="https://github.com/moodle/moodle/commit/7223cd2518ad3b37901b736d6b62e7badd4ecaa1">version 3.0.6+</a> with a dedicated memcached server which @IP:port is 192.168.33.14:11211.</p>

<h2 id="set-up-a--memcached-server">Set up a  memcached server</h2>

<p>see <a href="/blog2018-01-11-php7-nginx-memcached-session">this post</a>.</p>

<h2 id="configure-moodle">Configure moodle</h2>

<p>Configure <a href="https://docs.moodle.org/30/en/Session_handling#Memcached">session handling</a> in <code>config.php</code>:</p>

<pre><code>/********************************************/
//MEMCACHED SETUP
$CFG-&gt;session_handler_class = '\core\session\memcached';
$CFG-&gt;session_memcached_save_path = '192.168.33.14:11211';
$CFG-&gt;session_memcached_prefix = 'memc.sess.key.';
$CFG-&gt;session_memcached_acquire_lock_timeout = 120;
$CFG-&gt;session_memcached_lock_expire = 7200;       // Ignored if memcached extension &lt;= 2.1.0
/********************************************/
</code></pre>

<h2 id="checkings">Checkings</h2>

<h2 id="moodle-cookie">Moodle cookie</h2>

<p>If you print out your cookie from your debug tool in your bowser, you well see a cookie named <code>MoodleSession</code></p>

<p>In my case it has value <code>4gp94gr17g78jnh97a6mfml0b4</code></p>

<h2 id="moodle-database">Moodle database</h2>

<p>Now let's check if there is still record in DB for your cookie session:</p>

<pre><code>SELECT * FROM mdl_sessions WHERE sid='4gp94gr17g78jnh97a6mfml0b4';
</code></pre>

<p>returns:</p>

<pre><code>2507694 0   4gp94gr17g78jnh97a6mfml0b4  48521       1515679016  1515681908  192.168.33.1    192.168.33.1
</code></pre>

<p>What ??? I was expecting to have no more entries in the mdl_sessions table.
After searching a little bit more, I found the explanation <a href="https://moodle.org/mod/forum/discuss.php?d=326352">here</a>:</p>

<pre><code>Normally when you have sessions stored in Memcache/d there will still be a record of the session written to mdl_sessions. The session data is not written to the database, it's only written to the memcache/d server itself. The performance gain is seen because the session data is not written every page view for every user, and thus the table rows are not continually being locked and unlocked.
</code></pre>

<h2 id="memcached-server">memcached server</h2>

<p>Let's check if there is a key/value record for ou session:</p>

<script src="https://gist.github.com/benIT/2e63d3541f4f46d9a47777d467549d2e.js"></script>

<p>run it:</p>

<pre><code>php memcached.php | grep 4gp94gr17g78jnh97a6mfml0b4
</code></pre>

<p>prints:</p>

<pre><code>key: memc.sess.key.4gp94gr17g78jnh97a6mfml0b4
</code></pre>

<p>which means that our session is written in memcached! That's ok!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Docker 101:  basics]]></title>
            <link href="/blog/2017/12/08/docker-basics"/>
            <updated>2017-12-08T00:00:00+00:00</updated>
            <id>/blog/2017/12/08/docker-basics</id>
            <content type="html"><![CDATA[<h2 id="containers">Containers</h2>

<p>A container is a way to create isolated env that can run code while sharing a single OS.</p>

<h3 id="run-a-container">Run a container</h3>

<pre><code>docker container run -p 9999:80 httpd:2.4
</code></pre>

<p>The <code>--detach</code> flag can be used to run the container in background:</p>

<pre><code>docker container run --detach -p 9999:80 httpd:2.4
</code></pre>

<h3 id="list-containers">List containers</h3>

<pre><code>docker container ls
</code></pre>

<h3 id="run-commands-on-container">Run commands on container</h3>

<pre><code>docker container exec my_container_name du -mh
</code></pre>

<h3 id="attaching-a-shell-to-a-container">Attaching a Shell to a Container</h3>

<p>To get a shell inside the container:</p>

<pre><code>docker container exec -it my_container_name /bin/bash

PATH=$PATH:/usr/games/
export PATH
</code></pre>

<h2 id="dockerfiles">Dockerfiles</h2>

<p>Dockerfile -> create an image -> to generate a container</p>

<p>Inside a file named <code>Dockerfile</code>.</p>

<h3 id="dockerfile-example">Dockerfile example</h3>

<pre><code>FROM httpd:2.4
EXPOSE 80
RUN apt-get update &amp;&amp; apt-get install -y fortunes
COPY page.html /var/www/html/
LABEL maintainer="moby-dock@example.com"
</code></pre>

<h3 id="building-an-image-from-a-dockerfile">Building an Image From a Dockerfile</h3>

<pre><code>docker image build --tag web-server:1.0 .
</code></pre>

<p>End the command with a single . so it knows to look for the Dockerfile in the same folder that the command is run in.</p>

<pre><code>docker image ls


docker container run -p 80:80 web-server:1.0
</code></pre>

<h2 id="volumes">Volumes</h2>

<p>It is possible to copy files into a container but files will be lost when container stops.</p>

<pre><code>docker container cp page.html my_container_name:/var/www/html/.
</code></pre>

<p>A better solution is to use volumes.
Data volumes expose files on your host machine to the container.</p>

<h3 id="creating-a-volume">Creating a Volume</h3>

<pre><code>docker run -d -p 80:80 -v /my-files:/var/www/html web-server:1.1
</code></pre>

<p>Shared folder  between <code>/my-files</code> on host machine and the <code>html</code> folder in the container</p>
]]></content>
        </entry>
    </feed>